<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PBL Game - Map Editor</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #1a1a2e;
      color: #eee;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    .sidebar {
      width: 250px;
      background-color: #16213e;
      padding: 15px;
      display: flex;
      flex-direction: column;
      border-right: 2px solid #0f3460;
    }

    .sidebar h2 {
      color: #e94560;
      margin-bottom: 15px;
      text-align: center;
    }

    .tile-palette {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 20px;
      flex: 1;
      overflow-y: auto;
      padding-right: 5px;
    }

    .tile-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
      background-color: #0f3460;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .tile-item:hover {
      background-color: #1a4a7a;
    }

    .tile-item.selected {
      border-color: #e94560;
      background-color: #1a4a7a;
    }

    .tile-item canvas,
    .tile-item img {
      border: 1px solid #333;
      image-rendering: pixelated;
    }

    .tile-item span {
      margin-top: 5px;
      font-size: 11px;
      text-align: center;
      color: #aaa;
    }

    .tools {
      margin-top: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .tools button {
      padding: 12px;
      background-color: #e94560;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: background-color 0.2s;
    }

    .tools button:hover {
      background-color: #ff6b6b;
    }

    .tools button.secondary {
      background-color: #0f3460;
    }

    .tools button.secondary:hover {
      background-color: #1a4a7a;
    }

    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 15px;
      overflow: hidden;
    }

    .toolbar {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }

    .toolbar input[type="text"] {
      padding: 8px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background-color: #16213e;
      color: #eee;
      width: 150px;
    }

    .toolbar select {
      padding: 8px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background-color: #16213e;
      color: #eee;
    }

    .info {
      font-size: 12px;
      color: #888;
      margin-left: auto;
    }

    .canvas-container {
      flex: 1;
      overflow: auto;
      background-color: #0d0d1a;
      border-radius: 8px;
      padding: 10px;
    }

    #mapCanvas {
      image-rendering: pixelated;
      cursor: crosshair;
      display: block;
    }

    .toolbar-btn {
      padding: 8px 12px;
      background-color: #0f3460;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .toolbar-btn:hover {
      background-color: #1a4a7a;
    }

    .mode-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }

    .mode-tab {
      flex: 1;
      padding: 8px;
      background-color: #0f3460;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .mode-tab.active {
      background-color: #e94560;
    }

    .mode-tab:hover {
      background-color: #1a4a7a;
    }

    .object-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
      background-color: #0f3460;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
      position: relative;
    }

    .object-item:hover {
      background-color: #1a4a7a;
    }

    .object-item.selected {
      border-color: #e94560;
      background-color: #1a4a7a;
    }

    .object-item canvas {
      border: 1px solid #333;
      image-rendering: pixelated;
      max-width: 100%;
      max-height: 60px;
    }

  </style>
</head>
<body>
  <div class="sidebar">
    <h2>PBL 專題</h2>
    <div class="mode-tabs">
      <button class="mode-tab active" id="tileModeBtn" onclick="switchMode('tile')">地板</button>
      <button class="mode-tab" id="objectModeBtn" onclick="switchMode('object')">物件</button>
    </div>
    <div class="tile-palette" id="tilePalette">
    </div>
    <div class="tile-palette" id="objectPalette" style="display: none;">
    </div>

    <div class="tools">
      <button onclick="document.getElementById('assetUpload').click()">上傳素材</button>
      <input type="file" id="assetUpload" accept="image/*" multiple style="display: none" onchange="uploadAssets(event)">
      <button onclick="document.getElementById('objectUpload').click()">上傳物件</button>
      <input type="file" id="objectUpload" accept="image/*" multiple style="display: none" onchange="uploadObjects(event)">
      <button onclick="fillAll()">填滿整個地圖</button>
      <button class="secondary" onclick="clearMap()">清空地圖</button>
      <button class="secondary" onclick="exportTMX()">導出地圖</button>
      <button class="secondary" onclick="exportObjects()">導出物件</button>
    </div>
  </div>

  <div class="main-area">
    <div class="toolbar">
      <label>
        地圖名稱:
        <input type="text" id="mapName" value="new-map">
      </label>
      <button class="toolbar-btn" onclick="document.getElementById('importFile').click()">導入 TMX</button>
      <input type="file" id="importFile" accept=".tmx" style="display: none" onchange="importTMX(event)">
      <button class="toolbar-btn" onclick="document.getElementById('importMetaFile').click()">導入 物件</button>
      <input type="file" id="importMetaFile" accept=".json" style="display: none" onchange="importMeta(event)">
      <div class="info">
        <span id="cursorInfo">座標: -</span> |
        <span id="rotationInfo">旋轉: 0°</span> |
        <span>R 旋轉 | Q 逆旋轉 | Cmd+Z 復原</span>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="mapCanvas" width="1280" height="720"></canvas>
    </div>
  </div>


  <script>
    const TILE_SIZE = 40;
    const MAP_WIDTH = 32;
    const MAP_HEIGHT = 18;

    const TILES = [
      { id: 1, name: 'blue_stone', x: 0, y: 0, size: 1 },
      { id: 2, name: 'dark_stone', x: 1, y: 0, size: 1 },
      { id: 3, name: 'dirt_cliff', x: 2, y: 0, size: 2 },
      { id: 4, name: 'dirt_path', x: 3, y: 0, size: 2 },
      { id: 5, name: 'grass_floor', x: 4, y: 0, size: 1 },
      { id: 6, name: 'ice_floor', x: 5, y: 0, size: 1 },
      { id: 7, name: 'lava_brick', x: 6, y: 0, size: 1 },
      { id: 8, name: 'sand', x: 7, y: 0, size: 1 },
      { id: 9, name: 'snow_stone', x: 8, y: 0, size: 1 },
      { id: 10, name: 'snowfall', x: 9, y: 0, size: 1 },
      { id: 11, name: 'stone', x: 0, y: 1, size: 1 },
      { id: 12, name: 'wood_plank', x: 1, y: 1, size: 1 },
      { id: 13, name: 'all_black', x: 2, y: 1, size: 1 },
      { id: 14, name: 'stone_floor', x: 3, y: 1, size: 1 },
      { id: 15, name: 'grass_floor2', x: 4, y: 1, size: 1 },

      { id: 21, name: 'top_leading_gate', x: 0, y: 2, size: 1 },
      { id: 22, name: 'top_middle_gate', x: 1, y: 2, size: 1 },
      { id: 23, name: 'top_trailing_gate', x: 2, y: 2, size: 1 },
      { id: 24, name: 'middle_leading_gate', x: 3, y: 2, size: 1 },
      { id: 25, name: 'middle_middle_gate', x: 4, y: 2, size: 1 },
      { id: 26, name: 'middle_trailing_gate', x: 5, y: 2, size: 1 },
      { id: 27, name: 'bottom_leading_gate', x: 6, y: 2, size: 1 },
      { id: 28, name: 'bottom_middle_gate', x: 7, y: 2, size: 1 },
      { id: 29, name: 'bottom_trailing_gate', x: 8, y: 2, size: 1 },


      { id: 31, name: 'bridge_top', x: 0, y: 3, size: 1 },
      { id: 32, name: 'bridge_top_2', x: 1, y: 3, size: 1 },
      { id: 33, name: 'bridge_middle', x: 2, y: 3, size: 1 },
      { id: 34, name: 'bridge_bottom', x: 3, y: 3, size: 1 },
      { id: 35, name: 'bridge_bottom_2', x: 4, y: 3, size: 1 },

      { id: 41, name: 'stone', x: 0, y: 4, size: 1 },
      { id: 42, name: 'stone2', x: 1, y: 4, size: 1 },
      { id: 43, name: 'bridge_top', x: 2, y: 4, size: 1 },
      { id: 44, name: 'bridge_middle', x: 3, y: 4, size: 1 },
      { id: 45, name: 'bridge_bottom', x: 4, y: 4, size: 1 },

    ];

    let mapData = loadMapData();
    let undoStack = [];
    const MAX_UNDO = 50;
    let uploadedTiles = loadUploadedTiles();
    let uploadedImages = {};
    let currentMode = 'tile'; // 'tile' or 'object'
    let uploadedObjects = loadUploadedObjects();
    let objectImages = {};
    let mapObjects = loadMapObjects(); // Array of {img: string, collision: bool, x: int, y: int}
    let selectedObject = null;
    let objectCollision = true;

    function saveUndoState() {
      undoStack.push(JSON.stringify({
        mapData: mapData,
        mapObjects: mapObjects
      }));
      if (undoStack.length > MAX_UNDO) {
        undoStack.shift();
      }
    }

    function undo() {
      if (undoStack.length > 0) {
        const state = JSON.parse(undoStack.pop());
        mapData = state.mapData;
        mapObjects = state.mapObjects || [];
        renderMap();
        saveMapData();
        saveMapObjects();
      }
    }

    function loadMapData() {
      const saved = localStorage.getItem('pbl-map-data');
      if (saved) {
        return JSON.parse(saved);
      }
      let data = [];
      for (let y = 0; y < MAP_HEIGHT; y++) {
        data[y] = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
          data[y][x] = 5;
        }
      }
      return data;
    }

    function saveMapData() {
      localStorage.setItem('pbl-map-data', JSON.stringify(mapData));
      localStorage.setItem('pbl-map-name', document.getElementById('mapName').value);
    }

    function loadMapObjects() {
      const saved = localStorage.getItem('pbl-map-objects');
      return saved ? JSON.parse(saved) : [];
    }

    function saveMapObjects() {
      localStorage.setItem('pbl-map-objects', JSON.stringify(mapObjects));
    }

    function loadUploadedObjects() {
      const saved = localStorage.getItem('pbl-uploaded-objects');
      return saved ? JSON.parse(saved) : [];
    }

    function saveUploadedObjects() {
      localStorage.setItem('pbl-uploaded-objects', JSON.stringify(uploadedObjects));
    }

    function switchMode(mode) {
      currentMode = mode;
      document.getElementById('tileModeBtn').classList.toggle('active', mode === 'tile');
      document.getElementById('objectModeBtn').classList.toggle('active', mode === 'object');
      document.getElementById('tilePalette').style.display = mode === 'tile' ? 'grid' : 'none';
      document.getElementById('objectPalette').style.display = mode === 'object' ? 'grid' : 'none';
      selectedObject = null;
      renderMap();
    }

    function loadUploadedTiles() {
      const saved = localStorage.getItem('pbl-uploaded-tiles');
      return saved ? JSON.parse(saved) : [];
    }

    function saveUploadedTiles() {
      localStorage.setItem('pbl-uploaded-tiles', JSON.stringify(uploadedTiles));
    }

    let selectedTile = 5;
    let currentRotation = 0;

    const FLIP_H = 0x80000000;
    const FLIP_V = 0x40000000;
    const FLIP_D = 0x20000000;
    const CLEAR_FLAGS = 0x1FFFFFFF;

    function encodeRotation(tileId, rotation) {
      let flags = 0;
      switch (rotation % 4) {
        case 1: flags = FLIP_D | FLIP_H; break;
        case 2: flags = FLIP_H | FLIP_V; break;
        case 3: flags = FLIP_D | FLIP_V; break;
      }
      return (tileId | flags) >>> 0;
    }

    function decodeRotation(value) {
      const tileId = value & CLEAR_FLAGS;
      const h = (value & FLIP_H) !== 0;
      const v = (value & FLIP_V) !== 0;
      const d = (value & FLIP_D) !== 0;
      let rotation = 0;
      if (d && h && !v) rotation = 1;
      else if (h && v && !d) rotation = 2;
      else if (d && v && !h) rotation = 3;
      return { tileId, rotation };
    }

    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');

    const tilesetImg = new Image();
    tilesetImg.src = 'map.png';

    tilesetImg.onload = () => {
      preloadUploadedImages();
      preloadObjectImages();
      initPalette();
      initObjectPalette();
      renderMap();
      const savedName = localStorage.getItem('pbl-map-name');
      if (savedName) {
        document.getElementById('mapName').value = savedName;
      }
    };

    function preloadUploadedImages() {
      uploadedTiles.forEach(tile => {
        const img = new Image();
        img.onload = () => {
          uploadedImages[tile.id] = img;
          renderMap();
        };
        img.src = tile.dataUrl;
      });
    }

    function preloadObjectImages() {
      uploadedObjects.forEach(obj => {
        const img = new Image();
        img.onload = () => {
          objectImages[obj.name] = img;
          renderMap();
        };
        img.src = obj.dataUrl;
      });
    }

    function initPalette() {
      const palette = document.getElementById('tilePalette');
      palette.innerHTML = '';

      TILES.forEach(tile => {
        const item = document.createElement('div');
        item.className = 'tile-item' + (tile.id === selectedTile ? ' selected' : '');
        item.onclick = () => selectTile(tile.id);

        // Create img element and extract tile from tileset
        const img = document.createElement('img');
        img.width = TILE_SIZE;
        img.height = TILE_SIZE;
        img.style.display = 'block';
        
        // Extract tile from tileset using temporary canvas
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = TILE_SIZE;
        tempCanvas.height = TILE_SIZE;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.imageSmoothingEnabled = false;
        tempCtx.drawImage(
          tilesetImg,
          tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE,
          0, 0, TILE_SIZE, TILE_SIZE
        );
        img.src = tempCanvas.toDataURL();

        const label = document.createElement('span');
        label.textContent = `${tile.id}. ${tile.name}`;

        item.appendChild(img);
        item.appendChild(label);
        palette.appendChild(item);
      });

      uploadedTiles.forEach(tile => {
        const item = document.createElement('div');
        item.className = 'tile-item uploaded-tile' + (tile.id === selectedTile ? ' selected' : '');
        item.onclick = () => selectTile(tile.id);

        const img = document.createElement('img');
        img.width = TILE_SIZE;
        img.height = TILE_SIZE;
        img.src = tile.dataUrl;
        img.style.display = 'block';
        
        // Store image object for rendering
        const imgObj = new Image();
        imgObj.onload = () => {
          uploadedImages[tile.id] = imgObj;
        };
        imgObj.src = tile.dataUrl;

        const label = document.createElement('span');
        label.textContent = `${tile.id}. ${tile.name}`;

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.cssText = `
          position: absolute;
          top: 2px;
          right: 2px;
          width: 16px;
          height: 16px;
          background: #e94560;
          color: white;
          border: none;
          border-radius: 50%;
          font-size: 10px;
          cursor: pointer;
          display: none;
        `;
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteUploadedTile(tile.id);
        };

        item.style.position = 'relative';
        item.onmouseenter = () => deleteBtn.style.display = 'block';
        item.onmouseleave = () => deleteBtn.style.display = 'none';

        item.appendChild(img);
        item.appendChild(label);
        item.appendChild(deleteBtn);
        palette.appendChild(item);
      });
    }

    function initObjectPalette() {
      const palette = document.getElementById('objectPalette');
      palette.innerHTML = '';

      uploadedObjects.forEach(obj => {
        const item = document.createElement('div');
        item.className = 'object-item' + (selectedObject === obj.name ? ' selected' : '');
        item.onclick = () => selectObject(obj.name);

        const objCanvas = document.createElement('canvas');
        const img = objectImages[obj.name];
        if (img) {
          const maxSize = 60;
          const scale = Math.min(maxSize / img.width, maxSize / img.height);
          objCanvas.width = img.width * scale;
          objCanvas.height = img.height * scale;
          const objCtx = objCanvas.getContext('2d');
          objCtx.imageSmoothingEnabled = false;
          objCtx.drawImage(img, 0, 0, objCanvas.width, objCanvas.height);
        } else {
          objCanvas.width = 60;
          objCanvas.height = 60;
        }

        const label = document.createElement('span');
        label.textContent = obj.name;
        label.style.marginTop = '5px';
        label.style.fontSize = '11px';
        label.style.textAlign = 'center';
        label.style.color = '#aaa';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.cssText = `
          position: absolute;
          top: 2px;
          right: 2px;
          width: 16px;
          height: 16px;
          background: #e94560;
          color: white;
          border: none;
          border-radius: 50%;
          font-size: 10px;
          cursor: pointer;
          display: none;
        `;
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteUploadedObject(obj.name);
        };

        item.style.position = 'relative';
        item.onmouseenter = () => deleteBtn.style.display = 'block';
        item.onmouseleave = () => deleteBtn.style.display = 'none';

        item.appendChild(objCanvas);
        item.appendChild(label);
        item.appendChild(deleteBtn);
        palette.appendChild(item);
      });
    }

    function selectObject(name) {
      selectedObject = name;
      document.querySelectorAll('.object-item').forEach(item => {
        item.classList.remove('selected');
      });
      document.querySelectorAll('.object-item').forEach(item => {
        if (item.onclick && item.onclick.toString().includes(`selectObject('${name}')`)) {
          item.classList.add('selected');
        }
      });
    }

    function selectTile(id) {
      selectedTile = id;
      document.querySelectorAll('.tile-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      document.querySelectorAll('.tile-item').forEach(item => {
        if (item.onclick.toString().includes(`selectTile(${id})`)) {
          item.classList.add('selected');
        }
      });
    }

    function renderMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const rendered = new Set();

      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          const key = `${x},${y}`;
          if (rendered.has(key)) continue;

          const value = mapData[y][x];
          const { tileId, rotation } = decodeRotation(value);
          const tile = TILES.find(t => t.id === tileId) || uploadedTiles.find(t => t.id === tileId);

          if (tile) {
            const tileSize = tile.size || 1;
            const scaledSize = TILE_SIZE * tileSize;

            const isTopLeft = checkIsTopLeft(x, y, tileId, tileSize);

            if (isTopLeft && tileSize > 1) {
              ctx.save();
              ctx.translate(x * TILE_SIZE + scaledSize / 2, y * TILE_SIZE + scaledSize / 2);
              ctx.rotate(rotation * Math.PI / 2);
              if (tile.dataUrl && uploadedImages[tileId]) {
                ctx.drawImage(uploadedImages[tileId], -scaledSize / 2, -scaledSize / 2, scaledSize, scaledSize);
              } else if (!tile.dataUrl) {
                ctx.drawImage(
                  tilesetImg,
                  tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE,
                  -scaledSize / 2, -scaledSize / 2, scaledSize, scaledSize
                );
              }
              ctx.restore();

              for (let dy = 0; dy < tileSize; dy++) {
                for (let dx = 0; dx < tileSize; dx++) {
                  rendered.add(`${x + dx},${y + dy}`);
                }
              }
            } else if (tileSize === 1) {
              ctx.save();
              ctx.translate(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
              ctx.rotate(rotation * Math.PI / 2);
              if (tile.dataUrl && uploadedImages[tileId]) {
                ctx.drawImage(uploadedImages[tileId], -TILE_SIZE / 2, -TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
              } else if (!tile.dataUrl) {
                ctx.drawImage(
                  tilesetImg,
                  tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE,
                  -TILE_SIZE / 2, -TILE_SIZE / 2, TILE_SIZE, TILE_SIZE
                );
              }
              ctx.restore();
            }
          }
        }
      }

      // Render objects
      mapObjects.forEach(obj => {
        const img = objectImages[obj.img];
        if (img) {
          ctx.drawImage(img, obj.x * TILE_SIZE, obj.y * TILE_SIZE);
        }
      });

      function checkIsTopLeft(x, y, tileId, size) {
        if (size === 1) return true;
        for (let dy = 0; dy < size; dy++) {
          for (let dx = 0; dx < size; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= MAP_WIDTH || ny >= MAP_HEIGHT) return false;
            const { tileId: nTileId } = decodeRotation(mapData[ny][nx]);
            if (nTileId !== tileId) return false;
          }
        }
        return true;
      }

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;

      for (let x = 0; x <= MAP_WIDTH; x++) {
        ctx.beginPath();
        ctx.moveTo(x * TILE_SIZE, 0);
        ctx.lineTo(x * TILE_SIZE, canvas.height);
        ctx.stroke();
      }

      for (let y = 0; y <= MAP_HEIGHT; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * TILE_SIZE);
        ctx.lineTo(canvas.width, y * TILE_SIZE);
        ctx.stroke();
      }

      if (hoverX >= 0 && hoverY >= 0) {
        if (currentMode === 'tile') {
          const tile = TILES.find(t => t.id === selectedTile) || uploadedTiles.find(t => t.id === selectedTile);
          if (tile) {
            const tileSize = tile.size || 1;
            const scaledSize = TILE_SIZE * tileSize;
            const centerX = hoverX * TILE_SIZE + scaledSize / 2;
            const centerY = hoverY * TILE_SIZE + scaledSize / 2;

            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.translate(centerX, centerY);
            ctx.rotate(currentRotation * Math.PI / 2);
            if (tile.dataUrl && uploadedImages[selectedTile]) {
              // For uploaded tiles, always use TILE_SIZE (40x40) regardless of tile.size
              const img = uploadedImages[selectedTile];
              const displaySize = TILE_SIZE; // Always 40x40 for uploaded tiles
              ctx.drawImage(img, -displaySize / 2, -displaySize / 2, displaySize, displaySize);
            } else if (!tile.dataUrl) {
              ctx.drawImage(
                tilesetImg,
                tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE,
                -scaledSize / 2, -scaledSize / 2, scaledSize, scaledSize
              );
            }
            ctx.restore();

            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 2;
            const previewWidth = Math.min(tileSize, MAP_WIDTH - hoverX) * TILE_SIZE;
            const previewHeight = Math.min(tileSize, MAP_HEIGHT - hoverY) * TILE_SIZE;
            ctx.strokeRect(hoverX * TILE_SIZE, hoverY * TILE_SIZE, previewWidth, previewHeight);
          }
        } else if (currentMode === 'object' && selectedObject) {
          const img = objectImages[selectedObject];
          if (img) {
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.drawImage(img, hoverX * TILE_SIZE, hoverY * TILE_SIZE);
            ctx.restore();

            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 2;
            ctx.strokeRect(hoverX * TILE_SIZE, hoverY * TILE_SIZE, img.width, img.height);
          }
        }
      }
    }

    function fillAll() {
      saveUndoState();
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          mapData[y][x] = encodeRotation(selectedTile, currentRotation);
        }
      }
      renderMap();
      saveMapData();
    }

    function clearMap() {
      saveUndoState();
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          mapData[y][x] = 5;
        }
      }
      mapObjects = [];
      renderMap();
      saveMapData();
      saveMapObjects();
    }

    let isDrawing = false;
    let hoverX = -1;
    let hoverY = -1;

    canvas.addEventListener('mousedown', (e) => {
      if (currentMode === 'object' && e.button === 2) {
        // Right click to delete object
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX / TILE_SIZE);
        const y = Math.floor((e.clientY - rect.top) * scaleY / TILE_SIZE);
        deleteObjectAt(x, y);
        return;
      }
      saveUndoState();
      isDrawing = true;
      if (currentMode === 'tile') {
        paintTile(e);
      } else if (currentMode === 'object') {
        placeObject(e);
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      updateCursorInfo(e);
      updateHoverPosition(e);
      if (isDrawing) {
        if (currentMode === 'tile') {
          paintTile(e);
        } else if (currentMode === 'object') {
          placeObject(e);
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDrawing = false;
      hoverX = -1;
      hoverY = -1;
      renderMap();
      document.getElementById('cursorInfo').textContent = '座標: -';
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });

    function updateHoverPosition(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX / TILE_SIZE);
      const y = Math.floor((e.clientY - rect.top) * scaleY / TILE_SIZE);

      if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
        if (hoverX !== x || hoverY !== y) {
          hoverX = x;
          hoverY = y;
          renderMap();
        }
      }
    }

    function updateCursorInfo(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX / TILE_SIZE);
      const y = Math.floor((e.clientY - rect.top) * scaleY / TILE_SIZE);

      if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
        if (currentMode === 'tile') {
          const currentTileValue = mapData[y][x];
          const { tileId } = decodeRotation(currentTileValue);
          const currentTile = TILES.find(t => t.id === tileId) || uploadedTiles.find(t => t.id === tileId);
          const tileName = currentTile?.name || 'unknown';
          document.getElementById('cursorInfo').textContent = `Position: (${x}, ${y}) - ${tileName}`;
        } else {
          const objAtPos = mapObjects.find(obj => obj.x === x && obj.y === y);
          if (objAtPos) {
            document.getElementById('cursorInfo').textContent = `Position: (${x}, ${y}) - Object: ${objAtPos.img}`;
          } else {
            document.getElementById('cursorInfo').textContent = `Position: (${x}, ${y})`;
          }
        }
      }
    }

    function paintTile(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX / TILE_SIZE);
      const y = Math.floor((e.clientY - rect.top) * scaleY / TILE_SIZE);

      if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
        const tile = TILES.find(t => t.id === selectedTile) || uploadedTiles.find(t => t.id === selectedTile);
        const tileSize = tile?.size || 1;

        for (let dy = 0; dy < tileSize; dy++) {
          for (let dx = 0; dx < tileSize; dx++) {
            const px = x + dx;
            const py = y + dy;
            if (px >= 0 && px < MAP_WIDTH && py >= 0 && py < MAP_HEIGHT) {
              mapData[py][px] = encodeRotation(selectedTile, currentRotation);
            }
          }
        }
        renderMap();
        saveMapData();
      }
    }

    function placeObject(e) {
      if (!selectedObject) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX / TILE_SIZE);
      const y = Math.floor((e.clientY - rect.top) * scaleY / TILE_SIZE);

      if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
        // Remove existing object at this position
        mapObjects = mapObjects.filter(obj => !(obj.x === x && obj.y === y));
        
        // Add new object
        mapObjects.push({
          img: selectedObject,
          collision: objectCollision,
          x: x,
          y: y
        });
        
        renderMap();
        saveMapObjects();
      }
    }

    function deleteObjectAt(x, y) {
      mapObjects = mapObjects.filter(obj => !(obj.x === x && obj.y === y));
      renderMap();
      saveMapObjects();
    }

    function exportTMX() {
      const mapName = document.getElementById('mapName').value || 'new-map';

      let csvData = '';
      for (let y = 0; y < MAP_HEIGHT; y++) {
        csvData += mapData[y].join(',');
        if (y < MAP_HEIGHT - 1) csvData += ',\n';
      }

      const tmx = `<?xml version="1.0" encoding="UTF-8"?>
<map version="1.10" tiledversion="1.11.2" orientation="orthogonal" renderorder="right-down" width="${MAP_WIDTH}" height="${MAP_HEIGHT}" tilewidth="${TILE_SIZE}" tileheight="${TILE_SIZE}" infinite="0" nextlayerid="2" nextobjectid="1">
 <tileset firstgid="1" name="map" tilewidth="${TILE_SIZE}" tileheight="${TILE_SIZE}" tilecount="100" columns="10">
  <image source="map.png" width="400" height="400"/>
 </tileset>
 <layer id="1" name="Tile Layer 1" width="${MAP_WIDTH}" height="${MAP_HEIGHT}">
  <data encoding="csv">
${csvData}
</data>
 </layer>
</map>`;

      downloadFile(mapName + '.tmx', tmx);
    }

    function exportObjects() {
      const mapName = document.getElementById('mapName').value || 'new-map';
      
      const metaData = {
        collision_gid: [],
        exit: [],
        object: mapObjects.map(obj => ({
          img: obj.img,
          collision: obj.collision,
          x: obj.x,
          y: obj.y
        })),
        entity: {
          npc: []
        },
        music: "",
        walk_sound: ""
      };
      
      downloadFile(mapName + '.objects.json', JSON.stringify(metaData, null, 2));
    }

    function downloadFile(filename, content) {
      const mimeType = filename.endsWith('.json') ? 'application/json' : 'text/xml';
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R' || e.code === 'KeyR') {
        currentRotation = (currentRotation + 1) % 4;
        updateRotationDisplay();
        renderMap();
      }

      if (e.key === 'q' || e.key === 'Q' || e.code === 'KeyQ') {
        currentRotation = (currentRotation + 3) % 4;
        updateRotationDisplay();
        renderMap();
      }

      if ((e.metaKey || e.ctrlKey) && (e.key === 'z' || e.code === 'KeyZ')) {
        e.preventDefault();
        undo();
      }
    });

    function updateRotationDisplay() {
      const degrees = currentRotation * 90;
      document.getElementById('rotationInfo').textContent = `旋轉: ${degrees}°`;
    }

    function importTMX(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const content = e.target.result;
        const parser = new DOMParser();
        const xml = parser.parseFromString(content, 'text/xml');

        const dataElement = xml.querySelector('data');
        if (!dataElement) {
          alert('無法讀取地圖資料');
          return;
        }

        const csvData = dataElement.textContent.trim();
        const rows = csvData.split('\n');

        saveUndoState();

        for (let y = 0; y < MAP_HEIGHT && y < rows.length; y++) {
          const cols = rows[y].split(',');
          for (let x = 0; x < MAP_WIDTH && x < cols.length; x++) {
            const value = parseInt(cols[x].trim(), 10);
            if (!isNaN(value)) {
              mapData[y][x] = value;
            }
          }
        }

        const filename = file.name.replace('.tmx', '');
        document.getElementById('mapName').value = filename;

        renderMap();
        saveMapData();
        alert('導入成功！');
      };

      reader.readAsText(file);
      event.target.value = '';
    }

    function importMeta(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const content = JSON.parse(e.target.result);
          
          saveUndoState();
          
          if (content.object && Array.isArray(content.object)) {
            mapObjects = content.object.map(obj => ({
              img: obj.img,
              collision: obj.collision !== undefined ? obj.collision : true,
              x: obj.x,
              y: obj.y
            }));
            saveMapObjects();
          }
          
          renderMap();
          alert('導入 Meta 成功！');
        } catch (error) {
          alert('無法讀取 Meta 檔案：' + error.message);
        }
      };

      reader.readAsText(file);
      event.target.value = '';
    }

    function uploadAssets(event) {
      const files = Array.from(event.target.files);
      if (files.length === 0) return;

      files.forEach(file => {
        if (!file.type.startsWith('image/')) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const fileName = file.name.replace(/\.[^/.]+$/, "");
          
          const img = new Image();
          img.onload = () => {
            if (img.width !== 40 || img.height !== 40) {
              alert(`圖片尺寸必須是 40x40 像素。上傳的圖片是 ${img.width}x${img.height} 像素。`);
              return;
            }
            
            const nextId = Math.max(...TILES.map(t => t.id), ...uploadedTiles.map(t => t.id), 0) + 1;

            const newTile = {
              id: nextId,
              name: fileName,
              dataUrl: dataUrl,
              size: 1,
              uploadDate: new Date().toISOString()
            };

            uploadedTiles.push(newTile);
            uploadedImages[nextId] = img;
            saveUploadedTiles();

            const blob = dataURLtoBlob(dataUrl);
            const fileName_ext = file.name;
            saveAssetToFolder(blob, fileName_ext);

            initPalette();
          };
          img.src = dataUrl;
        };
        reader.readAsDataURL(file);
      });

      event.target.value = '';
    }

    function dataURLtoBlob(dataURL) {
      const arr = dataURL.split(',');
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new Blob([u8arr], { type: mime });
    }

    function saveAssetToFolder(blob, fileName) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function deleteUploadedTile(tileId) {
      if (confirm('確定要刪除這個素材嗎？')) {
        uploadedTiles = uploadedTiles.filter(tile => tile.id !== tileId);
        delete uploadedImages[tileId];
        saveUploadedTiles();
        
        if (selectedTile === tileId) {
          selectedTile = 5;
        }
        
        for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            const { tileId: currentTileId } = decodeRotation(mapData[y][x]);
            if (currentTileId === tileId) {
              mapData[y][x] = 5;
            }
          }
        }
        
        initPalette();
        renderMap();
        saveMapData();
      }
    }

    function uploadObjects(event) {
      const files = Array.from(event.target.files);
      if (files.length === 0) return;

      files.forEach(file => {
        if (!file.type.startsWith('image/')) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const fileName = file.name.replace(/\.[^/.]+$/, "");
          
          const img = new Image();
          img.onload = () => {
            const newObject = {
              name: fileName,
              dataUrl: dataUrl,
              uploadDate: new Date().toISOString()
            };

            uploadedObjects.push(newObject);
            objectImages[fileName] = img;
            saveUploadedObjects();

            const blob = dataURLtoBlob(dataUrl);
            const fileName_ext = file.name;
            saveAssetToFolder(blob, fileName_ext);

            initObjectPalette();
          };
          img.src = dataUrl;
        };
        reader.readAsDataURL(file);
      });

      event.target.value = '';
    }

    function deleteUploadedObject(name) {
      if (confirm('確定要刪除這個物件嗎？')) {
        uploadedObjects = uploadedObjects.filter(obj => obj.name !== name);
        delete objectImages[name];
        saveUploadedObjects();
        
        // Remove objects from map
        mapObjects = mapObjects.filter(obj => obj.img !== name);
        saveMapObjects();
        
        if (selectedObject === name) {
          selectedObject = null;
        }
        
        initObjectPalette();
        renderMap();
      }
    }
  </script>
</body>
</html>
